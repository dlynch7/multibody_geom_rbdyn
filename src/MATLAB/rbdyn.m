%% rbdyn.m
%
% Description:
%   This function computes the forward dynamics of a set of N rigid bodies,
%   each of whose configuration is an element of SE(3) and each of whose
%   twist is an element of se(3), the Lie algebra of SE(3).
%   The "system" configuration is the vertical concatenation of the 4x4
%   homogeneous transformation matrix for each body, resulting in an 4Nx4
%   array.
%   Likewise, the "system" twist is the vertical concatenation of the 6x1
%   twist vector of each body, resulting in a 6Nx1 array.
%
% Inputs:
%   t: time (scalar)
%   Twb_all: vertically concatenated configuration of the N rigid bodies'
%            CoM frames {b(n)} (n = 1,...,N) relative to the world frame 
%            {w}, each of which is represented as a 4x4 homogeneous 
%            transformation matrix, i.e., an element of SE(3).
%   Vb_all:  vertically concatenated body twist of each of the N rigid 
%            bodies, each of which is represented by a 6x1 vector whose 
%            elements are the components of an element of se(3).
%   params: a struct with many fields, generated by calling init_params().
%
% Outputs:
%   dVbdt_all: derivative of combined body twist Vb_all with respect to 
%              time (a 6Nx1 vector)

function dVbdt_all = rbdyn(t,Twb_all,Vb_all,params)

for n = 1:numel(params.bodies)
    Twb_row_start = 1 + (n-1)*4;
    Twb_row_end = Twb_row_start + 3;
    
    Twb_n = Twb_all(Twb_row_start:Twb_row_end,:);
    
    Vb_row_start = 1 + (n-1)*6;
    Vb_row_end = Vb_row_start + 5;
    Vb_n = Vb_all(Vb_row_start:Vb_row_end);
    
    % spatial inertia matrix in the n-th body frame {b(n)}:
    Gb = params.bodies{n}.dyn.inertia_matrix_6D;
    Gb_inv = diag(1./diag(Gb)); % no need to call inv() to compute Gb_inv

    % To compute wrench due to gravity, we define a frame {c} whose origin
    % is that of {b} but whose orientation is that of {w}:
    Twc = [eye(3),     Twb_n(1:3,4);
           zeros(1,3), 1];
    Tcw = TransInv(Twc);
    Tcb = Tcw*Twb_n;

    % wrench due to gravity expressed in {c} frame:
    Fgrav_c = [0;0;0;0;0;-params.bodies{n}.dyn.mass*params.dyn.grav];

    % wrench due to granular drag, expressed in {c} frame:
    Vc = Adjoint(Tcb)*Vb_n;
%     Fdrag_c = vec_compute_wrench_3DRFT(Twb_all,Vc,params);
    Fdrag_c = zeros(6,1);

    Fb = transpose(Adjoint(Tcb))*(Fgrav_c + Fdrag_c);

    dVbndt = Gb_inv*(transpose(ad(Vb_n))*Gb*Vb_n + Fb);
    dVbdt_all(Vb_row_start:Vb_row_end)  = dVbndt;
end

dVbdt_all = dVbdt_all(:);

end