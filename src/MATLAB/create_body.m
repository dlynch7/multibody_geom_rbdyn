%% create_body.m
%
%   body_params = create_body(body_name,primitive,semi_axes,mass)
%
% Description:
%   This function generates a struct body_params corresponding to a single
%   rigid body. This struct (or a cell array of similar structs) can then
%   be passed to init_params() to initialize all parameters for a
%   simulation.
%
% Inputs:
%   body_name: a string, by which the user can define a 'friendly' name for
%              the body
%   primitive: a string, by which the user specifies the body type. Can be
%       'ellipsoid',
%       'cylinder', or
%       'rect-prism'
%   semi_axes: a struct defining the body dimensions.
%              If primitive is 'ellipsoid' or 'rect_prism', semi_axes has
%              the following fields:
%       semi_axes.x: semi-axis length in x-direction
%       semi_axes.y: semi-axis length in y-direction
%       semi_axes.z: semi-axis length in z-direction
%              If primitive is 'cylinder', semi_axes has the following
%              fields:
%       semi_axes.r: cylinder radius
%       semi_axes.h: cylinder height
%   mass: body mass
%
% Outputs:
%   body_params: a struct with many fields, including
%       body_name: same as input argument
%       primitive: same as input argment
%       dyn: properties related to dynamics, including the following:
%           mass: same as input argment
%           inertia_matrix_3d: 3x3 diagonal rotational inertia matrix
%           inertia_matrix_6d: 6x6 diagonal spatial inertia matrix
%       geom
%           semi_axes: same as input argument
%           TR: object representing approximation of body surface as
%               triangulation (generated by MATLAB). Includes following:
%               Points: vertices of triangulation
%               ConnectivityList: edges of triangulation
%           areas: array containing the area of each face of the
%                  triangulation object
%       viz: various parameters used for visualizing the body:
%           face:
%               num: number of faces comprising the triangulation object
%               color: RGB triplet between [0,0,0] and [1,1,1]
%               alpha: transparency value between 0 and 1
%           edge:
%               color: RGB triplet between [0,0,0] and [1,1,1]
%               alpha: transparency value between 0 and 1

function body_params = create_body(body_name,primitive,semi_axes,mass)

body_params.body_name = body_name; % user-friendly name
body_params.primitive = primitive; % 'rect_prism','cylinder',or 'ellipsoid'
body_params.dyn.mass = mass;

switch primitive
    case 'rect-prism'
        % extract dimensions from input struct:
        l = 2*semi_axes.x; % length [m]
        w = 2*semi_axes.y; % width  [m]
        h = 2*semi_axes.z; % height [m]
        
        % inertia [kg*m^2] about each principal axis:
        Ixx = body_params.dyn.mass*(w^2 + h^2)/12;
        Iyy = body_params.dyn.mass*(l^2 + h^2)/12;
        Izz = body_params.dyn.mass*(l^2 + w^2)/12;
        
        % parameters that are intrinsic to rectangular prism geometry:
        body_params.geom.semi_axes.x = semi_axes.x;
        body_params.geom.semi_axes.y = semi_axes.y;
        body_params.geom.semi_axes.z = semi_axes.z;
        
        % visualization parameters that are not intrinsic to rectangular 
        % prism geometry:
        body_params.viz.face.num = 10;
        body_params.viz.face.color = 0.75*[1 1 0];
        body_params.viz.face.alpha = 0.5;
        body_params.viz.edge.color = [0 0 0];
        body_params.viz.edge.alpha = 0.25;
        
        % create a triangulation object to approximate the rectangular
        % prism (used when computing granular drag forces with RFT):
        body_params.geom.TR = rect_prism(l,w,h,body_params.viz.face.num);
        
        % compute the area of each triangle face:
        body_params.geom.areas = NaN(1,size(body_params.geom.TR,1)); % preallocate
        for s = 1:size(body_params.geom.TR,1)
            % vertices of current triangle element:
            vert_1 = body_params.geom.TR.Points(body_params.geom.TR.ConnectivityList(s,1),:);
            vert_2 = body_params.geom.TR.Points(body_params.geom.TR.ConnectivityList(s,2),:);
            vert_3 = body_params.geom.TR.Points(body_params.geom.TR.ConnectivityList(s,3),:);

            % area of triangle element:
            body_params.geom.areas(s) = norm(cross(vert_2-vert_1,vert_3-vert_1))/2;
        end
    case 'cylinder'
        % extract dimensions from input struct:
        r = semi_axes.r; % radius [m]
        h = 2*semi_axes.h; % height [m]
        
        % inertia [kg*m^2] about each principal axis:
        Ixx = body_params.dyn.mass*(3*(r^2) + h^2)/12;
        Iyy = Ixx;
        Izz = body_params.dyn.mass*(r^2)/2;
        
        % parameters that are intrinsic to cylinder geometry:
        body_params.geom.semi_axes.r = r;
        body_params.geom.semi_axes.h = h;
        
        % visualization parameterdimensions.cylinders that are not intrinsic to cylinder
        % geometry:
        body_params.viz.face.num = 40;
        body_params.viz.face.color = 0.75*[0 1 1];
        body_params.viz.face.alpha = 0.5;
        body_params.viz.edge.color = [0 0 0];
        body_params.viz.edge.alpha = 0.25;
        
        % this computation ensures triangulation elements aren't too
        % stretched or squished:
        num_levels = ceil(h*body_params.viz.face.num/(2*pi*r));
        
        [X,Y,Z] = cylinder(r*ones(1,num_levels),...
                           body_params.viz.face.num);
        Z = (Z-0.5).*h; % center at origin
        [k,~] = convhull(reshape(X,[],1),...
                         reshape(Y,[],1),...
                         reshape(Z,[],1));
        body_params.geom.TR = triangulation(k,reshape(X,[],1),...
                                              reshape(Y,[],1),...
                                              reshape(Z,[],1));
        % compute the area of each triangle face:
        body_params.geom.areas = NaN(1,size(body_params.geom.TR,1)); % preallocate
        for s = 1:size(body_params.geom.TR,1)
            % vertices of current triangle element:
            vert_1 = body_params.geom.TR.Points(body_params.geom.TR.ConnectivityList(s,1),:);
            vert_2 = body_params.geom.TR.Points(body_params.geom.TR.ConnectivityList(s,2),:);
            vert_3 = body_params.geom.TR.Points(body_params.geom.TR.ConnectivityList(s,3),:);

            % area of triangle element:
            body_params.geom.areas(s) = norm(cross(vert_2-vert_1,vert_3-vert_1))/2;
        end
    case 'ellipsoid'
        % geometry and inertia components for an ellipsoid:
        a = semi_axes.x; % ellispoid x-axis length [m]
        b = semi_axes.y; % ellispoid y-axis length [m]
        c = semi_axes.z; % ellispoid z-axis length [m]
        Ixx = body_params.dyn.mass*(b^2 + c^2)/5;
        Iyy = body_params.dyn.mass*(a^2 + c^2)/5;
        Izz = body_params.dyn.mass*(a^2 + b^2)/5;
        
        % parameters that are intrinsic to ellipsoid geometry:
        body_params.geom.semi_axes.x = a;
        body_params.geom.semi_axes.y = b;
        body_params.geom.semi_axes.z = c;
        
        % visualization parameters that are not intrinsic to ellipsoid
        % geometry:
        body_params.viz.face.num = 40;
        body_params.viz.face.color = 0.75*[1 0 1];
        body_params.viz.face.alpha = 0.5;
        body_params.viz.edge.color = [0 0 0];
        body_params.viz.edge.alpha = 0.25;
        
        % create a triangulation object to approximate the ellipsoid (used
        % when computing granular drag forces with RFT):
        [x,y,z] = ellipsoid(0,0,0,a,b,c,body_params.viz.face.num);
        fvc = surf2patch(x,y,z,'triangles');
        body_params.geom.TR = triangulation(fvc.faces,fvc.vertices);
        
        % compute the area of each triangle face:
        body_params.geom.areas = NaN(1,size(body_params.geom.TR,1)); % preallocate
        for s = 1:size(body_params.geom.TR,1)
            % vertices of current triangle element:
            vert_1 = body_params.geom.TR.Points(body_params.geom.TR.ConnectivityList(s,1),:);
            vert_2 = body_params.geom.TR.Points(body_params.geom.TR.ConnectivityList(s,2),:);
            vert_3 = body_params.geom.TR.Points(body_params.geom.TR.ConnectivityList(s,3),:);

            % area of triangle element:
            body_params.geom.areas(s) = norm(cross(vert_2-vert_1,vert_3-vert_1))/2;
        end
        
    otherwise
        error("Unrecognized input for 'body_name' argument.");
end

% inertia matrix (3x3) for center-of-mass (CoM) frame aligned with
% principal axes of inertia:
body_params.dyn.inertia_matrix_3D = diag([Ixx,Iyy,Izz]); 

% 6x6 spatial inertia matrix for CoM frame aligned with principal axes of
% inertia:
body_params.dyn.inertia_matrix_6D = [body_params.dyn.inertia_matrix_3D, zeros(3);
                                     zeros(3), body_params.dyn.mass*eye(3)];
end